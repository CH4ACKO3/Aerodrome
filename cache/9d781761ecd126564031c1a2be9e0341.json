{"expires":1743605056.881,"value":{"highlighted":"<!-- Syntax highlighted by torchlight.dev --><div class='line'><span style=\"color:#2f86d2; text-align: right; -webkit-user-select: none; user-select: none;\" class=\"line-number\">1</span><span style=\"color: #002339;\">class Object3D {\\npublic:\\n    std::string name;\\n    std::string integrator;\\n\\n    // \\u4f4d\\u7f6e\\u5750\\u6807\\uff08\\u5730\\u9762\\u7cfb\\uff09\\n    std::array&lt;double, 3&gt; pos;\\n\\n    // \\u901f\\u5ea6\\u5411\\u91cf\\uff08\\u5730\\u9762\\u7cfb\\uff09\\n    std::array&lt;double, 3&gt; vel;\\n\\n    // \\u89d2\\u901f\\u5ea6\\u5411\\u91cf\\uff08\\u5f39\\u4f53\\u7cfb\\uff09\\n    std::array&lt;double, 3&gt; ang_vel;\\n\\n    // \\u8f6c\\u52a8\\u60ef\\u91cf\\n    std::array&lt;double, 3&gt; J;\\n\\n    double V; // \\u901f\\u5ea6\\n\\n    // \\u63cf\\u8ff0\\u521a\\u4f53\\u59ff\\u6001\\u7684\\u516b\\u4e2a\\u89d2\\u5ea6\\n    double theta;    // \\u4fef\\u4ef0\\u89d2\\n    double phi;      // \\u504f\\u822a\\u89d2\\n    double gamma;    // \\u503e\\u659c\\u89d2\\n    double theta_v;  // \\u901f\\u5ea6\\u503e\\u89d2\\n    double phi_v;    // \\u901f\\u5ea6\\u504f\\u89d2\\n    double alpha;    // \\u653b\\u89d2\\n    double beta;     // \\u4fa7\\u6ed1\\u89d2\\n    double gamma_v;  // \\u901f\\u5ea6\\u503e\\u659c\\u89d2\\n\\n    py::dict initial_state;\\n\\n    Object3D() {}\\n\\n    Object3D(py::dict input_dict)\\n    {\\n        name = input_dict[\\&quot;name\\&quot;].cast&lt;std::string&gt;();\\n        integrator = input_dict[\\&quot;integrator\\&quot;].cast&lt;std::string&gt;();\\n        pos = input_dict[\\&quot;pos\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        vel = input_dict[\\&quot;vel\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        ang_vel = input_dict[\\&quot;ang_vel\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        J = input_dict[\\&quot;J\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        // V = input_dict[\\&quot;V\\&quot;].cast&lt;double&gt;();\\n        V = sqrt(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]);\\n        theta = input_dict[\\&quot;theta\\&quot;].cast&lt;double&gt;();\\n        phi = input_dict[\\&quot;phi\\&quot;].cast&lt;double&gt;();\\n        gamma = input_dict[\\&quot;gamma\\&quot;].cast&lt;double&gt;();\\n        theta_v = input_dict[\\&quot;theta_v\\&quot;].cast&lt;double&gt;();\\n        phi_v = input_dict[\\&quot;phi_v\\&quot;].cast&lt;double&gt;();\\n        gamma_v = input_dict[\\&quot;gamma_v\\&quot;].cast&lt;double&gt;();\\n        alpha = input_dict[\\&quot;alpha\\&quot;].cast&lt;double&gt;();\\n        beta = input_dict[\\&quot;beta\\&quot;].cast&lt;double&gt;();\\n\\n        initial_state = input_dict;\\n    }\\n\\n    virtual void reset()\\n    {\\n        *this = Object3D(initial_state);\\n    }\\n\\n    virtual py::dict to_dict()\\n    {\\n        py::dict output_dict;\\n        output_dict[\\&quot;pos\\&quot;] = pos;\\n        output_dict[\\&quot;vel\\&quot;] = vel;\\n        output_dict[\\&quot;ang_vel\\&quot;] = ang_vel;\\n        output_dict[\\&quot;J\\&quot;] = J;\\n        output_dict[\\&quot;V\\&quot;] = V;\\n        output_dict[\\&quot;theta\\&quot;] = theta;\\n        output_dict[\\&quot;phi\\&quot;] = phi;\\n        output_dict[\\&quot;gamma\\&quot;] = gamma;\\n        output_dict[\\&quot;theta_v\\&quot;] = theta_v;\\n        output_dict[\\&quot;phi_v\\&quot;] = phi_v;\\n        output_dict[\\&quot;alpha\\&quot;] = alpha;\\n        output_dict[\\&quot;beta\\&quot;] = beta;\\n        output_dict[\\&quot;gamma_v\\&quot;] = gamma_v;\\n        output_dict[\\&quot;name\\&quot;] = name;\\n        return output_dict;\\n    }\\n\\n    virtual py::object step(py::dict action)\\n    {\\n        double dt = action[\\&quot;dt\\&quot;].cast&lt;double&gt;();\\n\\n        pos = action[\\&quot;pos\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        vel = action[\\&quot;vel\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        ang_vel = action[\\&quot;ang_vel\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        J = action[\\&quot;J\\&quot;].cast&lt;std::array&lt;double, 3&gt;&gt;();\\n        // V = action[\\&quot;V\\&quot;].cast&lt;double&gt;();\\n        V = sqrt(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]);\\n        theta = action[\\&quot;theta\\&quot;].cast&lt;double&gt;();\\n        phi = action[\\&quot;phi\\&quot;].cast&lt;double&gt;();\\n        gamma = action[\\&quot;gamma\\&quot;].cast&lt;double&gt;();\\n        theta_v = action[\\&quot;theta_v\\&quot;].cast&lt;double&gt;();\\n        phi_v = action[\\&quot;phi_v\\&quot;].cast&lt;double&gt;();\\n        gamma_v = action[\\&quot;gamma_v\\&quot;].cast&lt;double&gt;();\\n        alpha = action[\\&quot;alpha\\&quot;].cast&lt;double&gt;();\\n        beta = action[\\&quot;beta\\&quot;].cast&lt;double&gt;();\\n\\n        if (integrator == \\&quot;euler\\&quot;)\\n        {\\n            *this = *this + this-&gt;d() * dt;\\n        }\\n        else if (integrator == \\&quot;midpoint\\&quot;)\\n        {\\n            auto temp1 = *this + this-&gt;d() * (0.5 * dt);\\n            auto k1 = temp1.d();\\n            *this = *this + k1 * dt;\\n        }\\n        else if (integrator == \\&quot;rk23\\&quot;)\\n        {\\n            auto k1 = this-&gt;d();\\n            auto temp1 = *this + k1 * (0.5 * dt);\\n            auto k2 = temp1.d();\\n            auto temp2 = *this + k2 * (0.5 * dt);\\n            auto k3 = temp2.d();\\n            *this = *this + (k1 + k2 * 2 + k3) * (dt / 4);\\n        }\\n        else if (integrator == \\&quot;rk45\\&quot;)\\n        {\\n            auto k1 = this-&gt;d();\\n            auto temp1 = *this + k1 * (0.5 * dt);\\n            auto k2 = temp1.d();\\n            auto temp2 = *this + k2 * (0.5 * dt);\\n            auto k3 = temp2.d();\\n            auto temp3 = *this + k3 * dt;\\n            auto k4 = temp3.d();\\n            *this = *this + (k1 + k2 * 2 + k3 * 2 + k4) * (dt / 6);\\n        }\\n\\n        theta_v = atan2(vel[1], sqrt(vel[0] * vel[0] + vel[2] * vel[2]));\\n        phi_v = atan2(-vel[2], vel[0]);\\n\\n        beta = cos(theta_v) * (cos(gamma) * sin(phi - phi_v) + sin(theta) * sin(gamma) * cos(phi - phi_v)) - sin(theta_v) * cos(theta) * sin(gamma);\\n        alpha = (cos(theta_v) * (sin(theta) * cos(gamma) * cos(phi - phi_v) - sin(gamma) * sin(phi - phi_v)) - sin(theta_v) * cos(theta) * cos(gamma)) / cos(beta);\\n        gamma_v = (cos(alpha) * sin(beta) * sin(theta) - sin(alpha) * sin(beta) * cos(gamma) * cos(theta) + cos(beta) * sin(gamma) * cos(theta)) / cos(theta_v);\\n\\n        V = sqrt(vel[0] * vel[0] + vel[1] * vel[1] + vel[2] * vel[2]);\\n        return to_dict();\\n    }\\n\\n    virtual Object3D d()\\n    {\\n        auto derivative = *this;\\n\\n        derivative.pos[0] = vel[0];\\n        derivative.pos[1] = vel[1];\\n        derivative.pos[2] = vel[2];\\n\\n        derivative.vel[0] = 0;\\n        derivative.vel[1] = 0;\\n        derivative.vel[2] = 0;\\n\\n        derivative.ang_vel[0] = 0;\\n        derivative.ang_vel[1] = 0;\\n        derivative.ang_vel[2] = 0;\\n\\n        derivative.theta = ang_vel[1] * sin(gamma) + ang_vel[2] * cos(gamma);\\n        derivative.phi = (ang_vel[1] * cos(gamma) - ang_vel[2] * sin(gamma)) / cos(theta);\\n        derivative.gamma = ang_vel[0] * - tan(theta) * (ang_vel[1] * cos(gamma) - ang_vel[2] * sin(gamma));\\n\\n        derivative.theta_v = 0;\\n        derivative.phi_v = 0;\\n        derivative.gamma_v = 0;\\n\\n        derivative.alpha = 0;\\n        derivative.beta = 0;\\n\\n        return derivative;\\n    }\\n\\n    template&lt;typename T, typename P&gt;\\n    friend T operator+(const T&amp; lop, const P&amp; rop)\\n    {\\n        auto result = lop;\\n\\n        for (int i = 0; i &lt; 3; ++i)\\n        {   \\n            result.pos[i] = lop.pos[i] + rop.pos[i];\\n            result.vel[i] = lop.vel[i] + rop.vel[i];\\n            result.ang_vel[i] = lop.ang_vel[i] + rop.ang_vel[i];\\n        }   \\n\\n        result.V = lop.V + rop.V;\\n        result.theta = lop.theta + rop.theta;\\n        result.phi = lop.phi + rop.phi;\\n        result.gamma = lop.gamma + rop.gamma;\\n        result.theta_v = lop.theta_v + rop.theta_v;\\n        result.phi_v = lop.phi_v + rop.phi_v; \\n        result.alpha = lop.alpha + rop.alpha;\\n        result.beta = lop.beta + rop.beta;\\n        result.gamma_v = lop.gamma_v + rop.gamma_v;\\n\\n        return result;\\n    }\\n\\n    template&lt;typename T, typename P&gt;\\n    friend T operator-(const T&amp; lop, const P&amp; rop)\\n    {\\n        auto result = lop;\\n\\n        for (int i = 0; i &lt; 3; ++i)\\n        {\\n            result.pos[i] = lop.pos[i] - rop.pos[i];\\n            result.vel[i] = lop.vel[i] - rop.vel[i];\\n            result.ang_vel[i] = lop.ang_vel[i] - rop.ang_vel[i];\\n        }\\n\\n        result.V = lop.V - rop.V;\\n        result.theta = lop.theta - rop.theta;\\n        result.phi = lop.phi - rop.phi;\\n        result.gamma = lop.gamma - rop.gamma;\\n        result.theta_v = lop.theta_v - rop.theta_v;\\n        result.phi_v = lop.phi_v - rop.phi_v;\\n        result.alpha = lop.alpha - rop.alpha;\\n        result.beta = lop.beta - rop.beta;\\n        result.gamma_v = lop.gamma_v - rop.gamma_v;\\n\\n        return result;\\n    }\\n\\n    template&lt;typename T&gt;\\n    friend T operator*(const T&amp; lop, const double&amp; rop)\\n    {\\n        auto result = lop;\\n\\n        for (int i = 0; i &lt; 3; ++i)\\n        {\\n            result.pos[i] = lop.pos[i] * rop; \\n            result.vel[i] = lop.vel[i] * rop;\\n            result.ang_vel[i] = lop.ang_vel[i] * rop;\\n        }   \\n\\n        result.V = lop.V * rop;\\n        result.theta = lop.theta * rop;\\n        result.phi = lop.phi * rop;\\n        result.gamma = lop.gamma * rop;\\n        result.theta_v = lop.theta_v * rop;\\n        result.phi_v = lop.phi_v * rop;\\n        result.alpha = lop.alpha * rop;\\n        result.beta = lop.beta * rop;\\n        result.gamma_v = lop.gamma_v * rop;\\n\\n        return result;\\n    }\\n\\n    template&lt;typename T&gt;\\n    friend T operator/(const T&amp; lop, const double&amp; rop)\\n    {\\n        auto result = lop;\\n\\n        for (int i = 0; i &lt; 3; ++i)\\n        {\\n            result.pos[i] = lop.pos[i] / rop; \\n            result.vel[i] = lop.vel[i] / rop;\\n            result.ang_vel[i] = lop.ang_vel[i] / rop;\\n        }   \\n\\n        result.V = lop.V / rop;\\n        result.theta = lop.theta / rop;\\n        result.phi = lop.phi / rop;\\n        result.gamma = lop.gamma / rop;\\n        result.theta_v = lop.theta_v / rop;\\n        result.phi_v = lop.phi_v / rop;   \\n        result.alpha = lop.alpha / rop;\\n        result.beta = lop.beta / rop;\\n        result.gamma_v = lop.gamma_v / rop;\\n\\n        return result;\\n    }\\n};</span></div>","classes":"torchlight","styles":"background-color: #FFFFFF; --theme-selection-background: #4373c2;"}}
