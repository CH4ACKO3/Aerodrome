{"expires":1743604837.323,"value":{"highlighted":"<!-- Syntax highlighted by torchlight.dev --><div class='line'><span style=\"color:#1b1f234d; text-align: right; -webkit-user-select: none; user-select: none;\" class=\"line-number\">1</span><span style=\"color: #24292e;\">class CartPoleEnv : public BaseEnv\\n{\\nprivate:\\n    double gravity = 9.81;\\n    double masscart = 1.0;\\n    double masspole = 0.1;\\n    double total_mass = masspole + masscart;\\n    double length = 0.5; // half the pole&#39;s length\\n    double polemass_length = masspole * length;\\n    double force_mag = 10.0;\\n    double tau = 0.02; // seconds between state updates\\n    std::string kinematic_integrator = \\&quot;euler\\&quot;;\\n\\n    double theta_threshold_radians = 12 * 2 * 3.1415926 / 360; // angle at which to fail the episode\\n    double x_threshold = 2.4; // distance at which to fail the episode\\n\\n    double x = 0;\\n    double theta = 0;\\n    double x_dot = 0;\\n    double theta_dot = 0;\\n\\n    int time_step = 0;\\n    int max_steps = 200;\\n    bool steps_beyond_done = false;\\n\\npublic:\\n    CartPoleEnv() {}\\n\\n    ~CartPoleEnv() {}\\n\\n    py::object reset() override\\n    {\\n        py::dict result;\\n        std::random_device rd;\\n        std::mt19937 gen(rd());\\n        std::uniform_real_distribution&lt;&gt; dis(-0.05, 0.05);\\n\\n        x = dis(gen);\\n        x_dot = dis(gen);\\n        theta = dis(gen);\\n        theta_dot = dis(gen);\\n        time_step = 0;\\n        steps_beyond_done = false;\\n\\n        result[\\&quot;observation\\&quot;] = py::make_tuple(x, x_dot, theta, theta_dot);\\n        result[\\&quot;info\\&quot;] = \\&quot;\\&quot;;\\n        return result;\\n    }\\n\\n    py::object step(const py::object&amp; input_dict) override\\n    {\\n        py::dict result;\\n        if (!input_dict.contains(\\&quot;action\\&quot;))\\n        {\\n            result[\\&quot;info\\&quot;] = \\&quot;input_dict does not contain &#39;action&#39;\\&quot;;\\n            return result;\\n        }\\n\\n        int action;\\n        try\\n        {\\n            action = input_dict[\\&quot;action\\&quot;].cast&lt;int&gt;();\\n        }\\n        catch (const std::exception &amp;e)\\n        {\\n            result[\\&quot;info\\&quot;] = std::string(\\&quot;failed to convert action to int: \\&quot;) + e.what();\\n            return result;\\n        }\\n\\n        if (action != 0 &amp;&amp; action != 1)\\n        {\\n            result[\\&quot;info\\&quot;] = \\&quot;action must be either 0 or 1\\&quot;;\\n            return result;\\n        }\\n\\n        double force = action * force_mag;\\n        double costheta = cos(theta);\\n        double sintheta = sin(theta);\\n\\n        // For the interested reader:\\n        // https://coneural.org/florian/papers/05_cart_pole.pdf\\n        double temp = (force + polemass_length * theta_dot * theta_dot * sintheta) / total_mass;\\n        double theta_acc = (gravity * sintheta - costheta * temp) / (length * (4.0 / 3.0 - masspole * costheta * costheta / total_mass));\\n        double x_acc = temp - polemass_length * theta_acc * costheta / total_mass;\\n\\n        if (kinematic_integrator == \\&quot;euler\\&quot;)\\n        {\\n            x = x + tau * x_dot;\\n            x_dot = x_dot + tau * x_acc;\\n            theta = theta + tau * theta_dot;\\n            theta_dot = theta_dot + tau * theta_acc;\\n        }\\n        else if (kinematic_integrator == \\&quot;semi-implicit-euler\\&quot;)\\n        {\\n            x_dot = x_dot + tau * x_acc;\\n            x = x + tau * x_dot;\\n            theta_dot = theta_dot + tau * theta_acc;\\n            theta = theta + tau * theta_dot;\\n        }\\n        else\\n        {\\n            result[\\&quot;info\\&quot;] = \\&quot;unknown kinematic integrator\\&quot;;\\n            return result;\\n        }\\n\\n        time_step ++;\\n        bool terminated = ((x &lt; -x_threshold) || (x &gt; x_threshold) || (theta &lt; -theta_threshold_radians) || (theta &gt; theta_threshold_radians));\\n        bool truncated = (time_step &gt;= max_steps);\\n\\n        double reward;\\n        if (!terminated &amp;&amp; !truncated)\\n        {\\n            reward = 1.0;\\n        }\\n        else if (!steps_beyond_done)\\n        {\\n            if (terminated)\\n            {\\n                reward = 0.0;\\n            }\\n            else if (truncated)\\n            {\\n                reward = 1.0;\\n            }\\n            steps_beyond_done = true;\\n        }\\n        else\\n        {\\n            reward = 0.0;\\n            result[\\&quot;info\\&quot;] = \\&quot;You are calling &#39;step()&#39; even though this environment has already returned terminated = True. \\&quot;\\n                              \\&quot;You should always call &#39;reset()&#39; once you receive &#39;terminated = True&#39; -- any further steps are undefined behavior.\\&quot;;\\n        }\\n\\n        result[\\&quot;observation\\&quot;] = py::make_tuple(x, x_dot, theta, theta_dot);\\n        result[\\&quot;reward\\&quot;] = reward;\\n        result[\\&quot;terminated\\&quot;] = terminated;\\n        result[\\&quot;truncated\\&quot;] = truncated;\\n\\n        if (!result.contains(\\&quot;info\\&quot;))\\n        {\\n            result[\\&quot;info\\&quot;] = \\&quot;\\&quot;;\\n        }\\n\\n        return result;\\n    }\\n};</span></div>","classes":"torchlight","styles":"background-color: #fff; --theme-selection-background: #e2e5e9;"}}
